#!/usr/bin/env python

import argparse
import logging
import os
import signal
import subprocess
import sys
import tempfile
import urllib.parse

import netifaces

import cicada
from cicada.communicator.socket.connect import geturl


def get_environment(world_size, rank, address, root_address):
    env = os.environ.copy()
    env["CICADA_WORLD_SIZE"] = str(world_size)
    env["CICADA_RANK"] = str(rank)
    env["CICADA_ADDRESS"] = str(address)
    env["CICADA_ROOT_ADDRESS"] = str(root_address)
    return env


def log_command(command, env, log):
    log.info(f"Command: {' '.join(command)}")
    log.info(f"  Environment:")
    log.info(f"    CICADA_WORLD_SIZE={env['CICADA_WORLD_SIZE']}")
    log.info(f"    CICADA_RANK={env['CICADA_RANK']}")
    log.info(f"    CICADA_ADDRESS={env['CICADA_ADDRESS']}")
    log.info(f"    CICADA_ROOT_ADDRESS={env['CICADA_ROOT_ADDRESS']}")


def public_ip():
    """Return a public-facing IP address."""
    gateway, interface = netifaces.gateways()["default"][netifaces.AF_INET]
    return netifaces.ifaddresses(interface)[netifaces.AF_INET][0]["addr"]


def basic_frontend(arguments, players, log):
    processes = []
    for world_size, rank, address, root_address in players:
        env = get_environment(world_size, rank, address, root_address)

        command = [sys.executable]
        if arguments.inspect:
            command += ["-i"]
        command += [arguments.program]
        command += arguments.args

        log_command(command, env, log)

        if not arguments.dry_run:
            processes.append(subprocess.Popen(command, env=env))

    if not arguments.dry_run:
        signal.signal(signal.SIGINT, signal.SIG_IGN)
        for process in processes:
            process.wait()


def tmux_panes_frontend(arguments, players, log):
    command = []
    for world_size, rank, address, root_address in players:
        if rank == 0:
            command += ["tmux", "new-session"]
        else:
            command += [";", "split-window", "-v", "-d"]

        command += ["-e", f"CICADA_WORLD_SIZE={world_size}"]
        command += ["-e", f"CICADA_RANK={rank}"]
        command += ["-e", f"CICADA_ADDRESS={address}"]
        command += ["-e", f"CICADA_ROOT_ADDRESS={root_address}"]
        command += [sys.executable]
        if arguments.inspect:
            command += ["-i"]
        command += [arguments.program]
        command += arguments.args

    command += [";", "select-layout", arguments.tmux_layout]

    log.info(f"Command: {' '.join(command)}")

    processes = []
    if not arguments.dry_run:
        processes.append(subprocess.Popen(command))

    if not arguments.dry_run:
        signal.signal(signal.SIGINT, signal.SIG_IGN)
        for process in processes:
            process.wait()


def tmux_windows_frontend(arguments, players, log):
    command = []
    for world_size, rank, address, root_address in players:
        if rank == 0:
            command += ["tmux", "new-session"]
        else:
            command += [";", "new-window", "-d"]

        command += ["-n", f"rank-{rank}"]
        command += ["-e", f"CICADA_WORLD_SIZE={world_size}"]
        command += ["-e", f"CICADA_RANK={rank}"]
        command += ["-e", f"CICADA_ADDRESS={address}"]
        command += ["-e", f"CICADA_ROOT_ADDRESS={root_address}"]
        command += [sys.executable]
        if arguments.inspect:
            command += ["-i"]
        command += [arguments.program]
        command += arguments.args

    log.info(f"Command: {' '.join(command)}")

    processes = []
    if not arguments.dry_run:
        processes.append(subprocess.Popen(command))

    if not arguments.dry_run:
        signal.signal(signal.SIGINT, signal.SIG_IGN)
        for process in processes:
            process.wait()


def xterm_frontend(arguments, players, log):
    processes = []
    for world_size, rank, address, root_address in players:
        env = get_environment(world_size, rank, address, root_address)

        command = ["xterm", "-e"]
        command += [sys.executable]
        if arguments.inspect:
            command += ["-i"]
        command += [arguments.program]
        command += arguments.args

        log_command(command, env, log)

        if not arguments.dry_run:
            processes.append(subprocess.Popen(command, env=env))

    if not arguments.dry_run:
        signal.signal(signal.SIGINT, signal.SIG_IGN)
        for process in processes:
            process.wait()


frontends = {
    "basic": basic_frontend,
    "tmux": tmux_panes_frontend,
    "tmux-windows": tmux_windows_frontend,
    "xterm": xterm_frontend,
}


parser = argparse.ArgumentParser(description="Cicada MPC tools.")
subparsers = parser.add_subparsers(title="commands (choose one)", dest="command")

# run
subparser = subparsers.add_parser("run", help="Run all Cicada processes on the local machine.")
subparser.add_argument("--dry-run", "-y", action="store_true", help="Don't start actual processes.")
subparser.add_argument("--frontend", "-f", choices=frontends.keys(), default="basic", help="Frontend to execute processes.")
subparser.add_argument("--inspect", "-i", action="store_true", help="Start a Python prompt after running program.")
subparser.add_argument("--root-address", default="tcp://127.0.0.1:25252", help="Root address.  Default: %(default)s")
subparser.add_argument("--tmux-layout", default="even-vertical", choices=["even-horizontal", "even-vertical", "tiled"], help="Pane layout for the tmux frontend. Default: %(default)s")
subparser.add_argument("--world-size", "-n", type=int, default=3, help="Number of players. Default: %(default)s")
subparser.add_argument("program", help="Program to execute.")
subparser.add_argument("args", nargs=argparse.REMAINDER, help="Program arguments.")

# start
subparser = subparsers.add_parser("start", help="Start one Cicada process.")
subparser.add_argument("--dry-run", "-y", action="store_true", help="Don't start actual processes.")
subparser.add_argument("--frontend", "-f", choices=frontends.keys(), default="basic", help="Frontend to execute processes.")
subparser.add_argument("--address", default=None, help="Network address. Default: tcp://127.0.0.1:25252 for player 0, otherwise tcp://127.0.0.1")
subparser.add_argument("--inspect", "-i", action="store_true", help="Start a Python prompt after running program.")
subparser.add_argument("--root-address", default=None, help="Root address. Default: same as --address for player 0, otherwise tcp://127.0.0.1:25252")
subparser.add_argument("--rank", type=int, required=True, help="Player rank.")
subparser.add_argument("--world-size", "-n", type=int, default=3, help="Number of players. Default: %(default)s")
subparser.add_argument("program", help="Program to execute.")
subparser.add_argument("args", nargs=argparse.REMAINDER, help="Program arguments.")

# version
subparser = subparsers.add_parser("version", help="Print the Cicada version.")


if __name__ == "__main__":
    arguments = parser.parse_args()

    if arguments.command is None:
        parser.print_help()

    logging.basicConfig(level=logging.INFO)
    log = logging.getLogger()
    log.name = os.path.basename(sys.argv[0])

    # run
    if arguments.command == "run":
        world_size = arguments.world_size

        root_address = urllib.parse.urlparse(arguments.root_address)
        if root_address.scheme not in ["file", "tcp"]:
            raise RuntimeError(f"--root-address scheme must be file or tcp, got {root_address.scheme} instead.")
        if root_address.scheme == "tcp" and root_address.port is None:
            raise RuntimeError("--root-address must specify a port number when the scheme is tcp.")

        addresses = []
        for rank in range(world_size):
            if rank == 0:
                addresses.append(arguments.root_address)
            else:
                if root_address.scheme == "file":
                    fd, path = tempfile.mkstemp()
                    os.close(fd)
                    addresses.append(f"file://{path}")
                if root_address.scheme == "tcp":
                    addresses.append(f"tcp://{root_address.hostname}")

        players = []
        for rank, address in enumerate(addresses):
            players.append((world_size, rank, address, addresses[0]))

        frontend = frontends[arguments.frontend]
        frontend(arguments, players, log)

    # start
    if arguments.command == "start":
        world_size = arguments.world_size
        if world_size < 1:
            raise RuntimeError("--world-size must be greater than zero.")

        rank = arguments.rank
        if rank < 0 or rank >= world_size:
            raise RuntimeError(f"--rank must be in the range [0, {world_size}).")

        address = arguments.address
        if address is None:
            address = "tcp://127.0.0.1:25252" if rank == 0 else "tcp://127.0.0.1"
        address = urllib.parse.urlparse(address)
        address = address.geturl()

        root_address = arguments.root_address
        if root_address is None:
            root_address = address if rank == 0 else "tcp://127.0.0.1:25252"
        root_address = urllib.parse.urlparse(root_address)
        root_address = root_address.geturl()

        players = [(world_size, rank, address, root_address)]
        frontend = frontends[arguments.frontend]
        frontend(arguments, players, log)

    # version
    if arguments.command == "version":
        print(cicada.__version__)


